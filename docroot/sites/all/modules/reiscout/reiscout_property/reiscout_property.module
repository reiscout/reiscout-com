<?php

class ReiscoutPropertyAddressIsNotSet extends Exception {}
class ReiscoutPropertyOwnerAddressIsNotSet extends Exception {}
class ReiscoutPropertyUserAddressIsNotSet extends Exception {}
class ReiscoutPropertyUserPhoneNumberIsNotSet extends Exception {}

define('REISCOUT_PROPERTY_NODE_TITLE_TO_CHANGE', 'Property #');
define('REISCOUT_PROPERTY_MESSAGE_TO_CHANGE', 'Property <em class="placeholder">Property #</em> has been created.');

/**
 * Implements hook_menu().
 */
function reiscout_property_menu() {
  $items['reiscout_property_get_c2d_report/%'] = array(
    'title' => 'Connect2Data Report',
    'description' => 'Returns a Connect2Data info for a property.',
    'page callback' => 'reiscout_property_get_c2d_report_page',
    'page arguments' => array(1),
    'access arguments' => array('make request to connect2data_api'),
    'file' => 'reiscout_property.pages.inc',
  );

  return $items;
}

/**
 * Implements hook_form_FORM_ID_alter
 */
function reiscout_property_form_property_node_form_alter(&$form, &$form_state, $form_id) {
  $form['field_zillow_mls'] = array(
    '#type' => 'hidden',
  );
  $form['field_zillow_status'] = array(
    '#type' => 'hidden',
  );
  $form['field_zillow_zpid'] = array(
    '#type' => 'hidden',
  );
}

/**
 * Implements hook_node_validate().
 */
function reiscout_property_node_validate($node, $form, &$form_state) {
  if ('property' != $node->type) {
    return;
  }

  $nw = entity_metadata_wrapper('node', $node);

  if (!$nw->field_address->value()) {
    return;
  }

  // Check if there is already another property with the same address
  $query = new EntityFieldQuery;
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'property')
    ->fieldCondition('field_address', 'thoroughfare', $nw->field_address->thoroughfare->value())
    ->fieldCondition('field_address', 'locality', $nw->field_address->locality->value())
    ->fieldCondition('field_address', 'administrative_area', $nw->field_address->administrative_area->value())
    ->fieldCondition('field_address', 'postal_code', $nw->field_address->postal_code->value());

  // We do not want to compare a node with itself
  if ($node->nid) {
    $query->propertyCondition('nid', $node->nid, '!=');
  }

  $count = $query->count()->execute();
  if ($count) {
    form_set_error('field_address', t('A property with the same address already exists.'));
  }
}

/**
 * Implements hook_node_update().
 */
function reiscout_property_node_update($node) {
  if ('property' != $node->type) {
    return;
  }

  // We use 'Automatic Entity Labels' module to automatic title creation for
  // a Property node. The module uses 'hook_exit' hook to generating a node
  // title and updating the node. But 'Node' module have already saved the node
  // with token title and set a message about it. So here we look for the
  // message and change it.
  if (module_exists('auto_entitylabel')) {
    if (REISCOUT_PROPERTY_NODE_TITLE_TO_CHANGE == $node->original->title
      && REISCOUT_PROPERTY_NODE_TITLE_TO_CHANGE != $node->title) {
      if (!empty($_SESSION['messages']['status'])) {
        for ($i = 0, $len = count($_SESSION['messages']['status']); $i < $len; ++$i) {
          if (REISCOUT_PROPERTY_MESSAGE_TO_CHANGE == $_SESSION['messages']['status'][$i]) {
            $_SESSION['messages']['status'][$i] = t('Property %title has been created.', array('%title' => $node->title));
          }
        }
      }
    }
  }
}

/**
 * Implements hook_node_access_records().
 *
 * We want to force these access rules:
 * - a user, who has an 'administrator' user role, can view the node;
 * - a user, who is the author of the node, can view the node;
 * - all the other users can view the node only if it is published and the
 *   'Place this lead on the marketplace' field of the node is set to true.
 */
function reiscout_property_node_access_records($node) {
  if ('property' == $node->type) {
    $grants = array();

    // We use GID 0 here for a user, who has an 'administrator' user role
    $grants[] = array(
      'realm' => 'reiscout_property',
      'gid' => 0,
      'grant_view' => 1,
      'grant_update' => 0,
      'grant_delete' => 0,
      'priority' => 0,
    );

    // We use $node->uid as GID here for a user, who is the author of the node.
    // We do not need to check if the super user has an access.
    if (1 != $node->uid) {
      $grants[] = array(
        'realm' => 'reiscout_property',
        'gid' => $node->uid,
        'grant_view' => 1,
        'grant_update' => 0,
        'grant_delete' => 0,
        'priority' => 0,
      );
    }

    // We use GID 1 here for all the other users
    $nw = entity_metadata_wrapper('node', $node);
    if ($nw->status->value() && $nw->field_place_on_marketplace->value()) {
      $grants[] = array(
        'realm' => 'reiscout_property',
        'gid' => 1,
        'grant_view' => 1,
        'grant_update' => 0,
        'grant_delete' => 0,
        'priority' => 0,
      );
    }

    return $grants;
  }
}

/**
 * Implements hook_node_grants().
 */
function reiscout_property_node_grants($account, $op) {
  $grants = array();

  if ('view' == $op) {
    // For all the users we want to check their access using GID 1
    $grants['reiscout_property'][] = 1;

    // If the user is logged in, check his access using his UID as a GID
    if ($account->uid) {
      $grants['reiscout_property'][] = $account->uid;
    }

    // If the user has an 'administrator' role, check his access using GID 0
    $role_admin = user_role_load_by_name('administrator');
    if (user_has_role($role_admin->rid, $account)) {
      $grants['reiscout_property'][] = 0;
    }
  }

  return $grants;
}

/**
 * Implements hook_field_access().
 */
function reiscout_property_field_access($op, $field, $entity_type, $entity, $account) {
  if ('node' == $entity_type && !empty($entity->type) && 'property' == $entity->type) {
    if ('edit' == $op) {
      if ('field_data_locked' == $field['field_name']) {
        $role_admin = user_role_load_by_name('administrator');
        if (!user_has_role($role_admin->rid, $account)) {
          return FALSE;
        }
      }
    }
  }
}

/**
 * Implements hook_node_access().
 */
function reiscout_property_node_access($node, $op, $account) {
  $type = is_string($node) ? $node : $node->type;

  if ('property' == $type) {
    if ('update' == $op) {
      if (is_object($node)) {
        $nw = entity_metadata_wrapper('node', $node);
        if ($nw->field_data_locked->value()) {
          return NODE_ACCESS_DENY;
        }
      }
    }
  }

  return NODE_ACCESS_IGNORE;
}

/**
 * Builds data that is needed for request to the Connect2Data API.
 */
function _reiscout_property_build_property_criteria($nid) {
  $nw = entity_metadata_wrapper('node', $nid);

  if (!$address = $nw->field_address->value()) {
    $message = "The property's !nid address was not set.";
    watchdog('reiscout_property', $message, array('!nid' => $nid), WATCHDOG_ERROR);
    return FALSE;
  }

  return array(
    'street_address' => $address['thoroughfare'],
    'city' => $address['locality'],
    'state' => $address['administrative_area'],
    'postal_code' => $address['postal_code'],
  );
}

/**
 * Makes a request to the Connect2Data API and returns full info about property.
 */
function _reiscout_property_get_c2d_report_by_nid($nid, $request_reason) {
  if ($property_criteria = _reiscout_property_build_property_criteria($nid)) {
    if ($report = connect2data_api_get_detailed_subject_report($property_criteria, $request_reason)) {
      return $report;
    }
  }

  return FALSE;
}

/**
 * Checks if an address of a property has been filled out.
 */
function _reiscout_property_is_address_filled_by_nid($nid) {
  $nw = entity_metadata_wrapper('node', $nid);

  if (!$nw->field_address->value()) {
    return FALSE;
  }

  return $nw->field_address->thoroughfare->value()
    && $nw->field_address->locality->value()
    && $nw->field_address->administrative_area->value()
    && $nw->field_address->postal_code->value();
}

/**
 * Returns an address of a property.
 */
function _reiscout_property_get_address_by_nid($nid) {
  if (!_reiscout_property_is_address_filled_by_nid($nid)) {
    $msg = t("An address of a property is empty or incomplete.");
    throw new ReiscoutPropertyAddressIsNotSet($msg);
  }

  $nw = entity_metadata_wrapper('node', $nid);

  return $nw->field_address;
}

/**
 * Checks if an address of a property's owner has been filled out.
 */
function _reiscout_property_is_owner_address_filled_by_nid($nid) {
  $nw = entity_metadata_wrapper('node', $nid);

  if (!$nw->field_owner_postal_address->value()) {
    return FALSE;
  }

  return $nw->field_owner_postal_address->name_line->value()
    && $nw->field_owner_postal_address->thoroughfare->value()
    && $nw->field_owner_postal_address->locality->value()
    && $nw->field_owner_postal_address->administrative_area->value()
    && $nw->field_owner_postal_address->postal_code->value();
}

/**
 * Returns an address of a property's owner.
 */
function _reiscout_property_get_owner_address_by_nid($nid) {
  if (!_reiscout_property_is_owner_address_filled_by_nid($nid)) {
    $msg = t("An address of a property's owner is empty or incomplete.");
    throw new ReiscoutPropertyOwnerAddressIsNotSet($msg);
  }

  $nw = entity_metadata_wrapper('node', $nid);

  return $nw->field_owner_postal_address;
}

/**
 * Checks if an address of a user has been filled out.
 */
function _reiscout_property_is_user_address_filled($uid = NULL) {
  global $user;

  if (!isset($uid)) {
    $uid = $user->uid;
  }

  $uw = entity_metadata_wrapper('user', $uid);

  if (!$uw->field_user_postal_address->value()) {
    return FALSE;
  }

  return $uw->field_user_postal_address->name_line->value()
    && $uw->field_user_postal_address->thoroughfare->value()
    && $uw->field_user_postal_address->locality->value()
    && $uw->field_user_postal_address->administrative_area->value()
    && $uw->field_user_postal_address->postal_code->value();
}

/**
 * Returns an address of a user.
 */
function _reiscout_property_get_user_address($uid = NULL) {
  global $user;

  if (!isset($uid)) {
    $uid = $user->uid;
  }

  if (!_reiscout_property_is_user_address_filled($uid)) {
    $msg = t('User postal address is empty or incomplete.');
    throw new ReiscoutPropertyUserAddressIsNotSet($msg);
  }

  $uw = entity_metadata_wrapper('user', $uid);

  return $uw->field_user_postal_address;
}

/**
 * Returns a phone number of a user.
 */
function _reiscout_property_get_user_phone($uid = NULL) {
  global $user;

  if (!isset($uid)) {
    $uid = $user->uid;
  }

  $uw = entity_metadata_wrapper('user', $uid);

  if (!$phone_number = $uw->field_user_phone_number->value()) {
    $msg = t('User phone number is not set.');
    throw new ReiscoutPropertyUserPhoneNumberIsNotSet($msg);
  }

  return $phone_number;
}
